"""
Linear Block Code Module (Hamming [7,4] Code)

This module implements a basic binary linear block code using the Hamming [7,4] scheme.
It provides functionality to encode 4-bit messages into 7-bit codewords, detect and
correct single-bit errors using syndrome decoding, and identify the location of errors
based on a precomputed syndrome table.

Main Features:
- Encoding of 4-bit binary messages using a generator matrix (G)
- Syndrome computation using a parity-check matrix (H)
- Syndrome table generation for error location mapping
- Decoding with single-bit error correction

Matrices:
- G: Generator matrix (4x7)
- H: Parity-check matrix (3x7)

Author: Rafael Campello (Jos√© Sampaio 08.12.2025)
"""

import numpy as np
import itertools

P = np.array([[1, 1, 0], [0, 1, 1], [1, 1, 1], [1, 0, 1]], dtype=np.uint8)
G = np.hstack((P, np.identity(4, dtype=np.uint8)))
H = np.hstack((np.identity(3, dtype=np.uint8), P.T))

assert(G.shape == (4, 7))
assert(H.shape == (3, 7))

def encode(message_input):
    """
    Encodes a 4-bit binary message into a 7-bit codeword using the generator matrix G.
    Args:
        message_input (array-like): A 4-element list or NumPy array of uint8 values (0 or 1).
    Returns:
        np.ndarray: A 7-bit encoded codeword (NumPy array of dtype uint8).
    """
    message_input = np.array(message_input, dtype=np.uint8)
    assert(message_input.shape == (4,))
    return (np.dot(message_input, G) % 2).astype(np.uint8)

def syndrome(codeword_input):
    """
    Computes the syndrome vector of a received 7-bit codeword using the parity-check matrix H.
    Args:
        codeword_input (np.ndarray): A 7-bit received codeword (NumPy array of dtype uint8).
    Returns:
        np.ndarray: A 3-bit syndrome vector indicating potential error positions.
    """
    assert(codeword_input.shape == (7,))
    syn_output = np.dot(codeword_input, H.T) % 2
    assert(syn_output.shape == (3,))
    return syn_output.astype(np.uint8)

def syndrome_table():
    """
    Generates a syndrome-to-error-position mapping for all single-bit errors in a [7,4] code.
    Returns:
        dict: A dictionary mapping syndrome tuples to the index of the flipped bit (0 to 6).
    """	
    syndrome_table = {}
    for i in range(0, 7):
        error=np.zeros(7, dtype=np.uint8)
        error[i] ^= 1
        syndrome_table[tuple(syndrome(error))] = i
    return syndrome_table
    
def syn2idx(syn_input, fitted_map):
    """
    Converts a syndrome vector into the corresponding error bit index using the syndrome table.
    Args:
        syn_input (np.ndarray): A 3-bit syndrome vector (dtype uint8).
        fitted_map (dict): Syndrome-to-index mapping (as generated by syndrome_table()).
    Returns:
        int: Index of the error bit (0-6), or -1 if the syndrome is not found.
    """
    assert(syn_input.dtype == np.uint8)
    return fitted_map.get(tuple(syn_input), -1)
    
def decode(r, syn_table):
    """
    Decodes a received 7-bit codeword by correcting a single-bit error (if any),
    using the syndrome decoding method.
    Args:
        r (np.ndarray): The received 7-bit codeword (dtype uint8).
        syn_table (dict): Precomputed syndrome table for error location.
    Returns:
        tuple: 
            - c_hat (np.ndarray): Corrected 7-bit codeword.
            - message_hat (np.ndarray): Decoded 4-bit original message.
            - error_info (str or int): "no error" or index (0-6) of corrected bit.
    """	
    syn = syndrome(r)
    if sum(syn) == 0:
        i = "no error"
        return r, r[3:], i
    
    e_location = syn2idx(syn, syn_table)
    e_hat = np.zeros(7, dtype=np.uint8)
    e_hat[e_location] ^= 1
    c_hat = r^e_hat
    return c_hat, c_hat[3:], e_location
